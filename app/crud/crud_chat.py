import uuid
from typing import List, Optional, Tuple

from sqlalchemy.orm import Session, joinedload, selectinload
from sqlalchemy import and_, or_, func, select, literal_column

from app.db import models
from app import schemas
from .base import CRUDBase # Changed to relative import for consistency
from .crud_user_relationship import user_relationship # For block list
from app.schemas.enums import RelationshipTypeEnum # For block list


class CRUDChatRoom(CRUDBase[models.ChatRoom, schemas.ChatRoomCreate, schemas.ChatRoomUpdate]):
    def get_by_anonymous_id(self, db: Session, *, anonymous_room_id: uuid.UUID) -> Optional[models.ChatRoom]:
        return db.query(models.ChatRoom).options(
            selectinload(models.ChatRoom.participants),
            selectinload(models.ChatRoom.messages).options(
                joinedload(models.ChatMessage.sender) # Eager load sender of last message
            )
        ).filter(models.ChatRoom.anonymous_room_id == anonymous_room_id).first()

    def get_direct_chat_by_participants(
        self, db: Session, *, user1_anonymous_id: uuid.UUID, user2_anonymous_id: uuid.UUID
    ) -> Optional[models.ChatRoom]:
        """
        Finds an existing direct (non-group) chat room between two specific users.
        """
        # This query is a bit complex. It looks for chat rooms that are not groups
        # and have exactly two participants, and those participants are user1 and user2.
        
        # Subquery to count participants per room
        participant_count_sq = (
            select(
                models.chatroom_participants_association.c.chatroom_id,
                func.count(models.chatroom_participants_association.c.user_anonymous_id).label("num_participants")
            )
            .group_by(models.chatroom_participants_association.c.chatroom_id)
            .subquery()
        )

        # Subquery to find rooms involving user1
        user1_rooms_sq = (
            select(models.chatroom_participants_association.c.chatroom_id.label("room_id"))
            .where(models.chatroom_participants_association.c.user_anonymous_id == user1_anonymous_id)
            .subquery()
        )

        # Subquery to find rooms involving user2
        user2_rooms_sq = (
            select(models.chatroom_participants_association.c.chatroom_id.label("room_id"))
            .where(models.chatroom_participants_association.c.user_anonymous_id == user2_anonymous_id)
            .subquery()
        )

        room = (
            db.query(models.ChatRoom)
            .join(participant_count_sq, models.ChatRoom.anonymous_room_id == participant_count_sq.c.chatroom_id)
            .join(user1_rooms_sq, models.ChatRoom.anonymous_room_id == user1_rooms_sq.c.room_id)
            .join(user2_rooms_sq, models.ChatRoom.anonymous_room_id == user2_rooms_sq.c.room_id)
            .filter(models.ChatRoom.is_group == False)
            .filter(participant_count_sq.c.num_participants == 2)
            .options(selectinload(models.ChatRoom.participants)) # Eager load participants
            .first()
        )
        return room

    def create_with_participants(
        self,
        db: Session,
        *,
        room_in: schemas.ChatRoomCreate,
        initiator_user: models.User,
        participant_users: List[models.User]
    ) -> models.ChatRoom:
        all_participants = list(set([initiator_user] + participant_users)) # Ensure initiator is included and unique

        if not room_in.is_group and len(all_participants) != 2:
            # This check should ideally be in the service/API layer before calling CRUD
            raise ValueError("Direct chats must have exactly two participants.")

        if not room_in.is_group:
            # For direct chats, check if one already exists
            existing_room = self.get_direct_chat_by_participants(
                db,
                user1_anonymous_id=all_participants[0].anonymous_id,
                user2_anonymous_id=all_participants[1].anonymous_id
            )
            if existing_room:
                return existing_room

        db_obj = models.ChatRoom(
            name=room_in.name if room_in.is_group else None, # Name only for group chats
            is_group=room_in.is_group,
            # anonymous_room_id is generated by default
        )
        db_obj.participants.extend(all_participants)
        
        db.add(db_obj)
        db.commit()
        db.refresh(db_obj)
        return db_obj

    def get_multi_for_user(
        self, db: Session, *, user_anonymous_id: uuid.UUID, skip: int = 0, limit: int = 100
    ) -> List[models.ChatRoom]:
        # First, fetch all chat rooms the user is part of
        all_user_chat_rooms_query = (
            db.query(models.ChatRoom)
            .join(models.ChatRoom.participants)
            .filter(models.User.anonymous_id == user_anonymous_id)
            .options(
                selectinload(models.ChatRoom.participants), # Eager load all participants for each room
                selectinload(models.ChatRoom.messages).options( # For last message
                    joinedload(models.ChatMessage.sender)
                ) 
            )
            .order_by(models.ChatRoom.updated_at.desc().nulls_last(), models.ChatRoom.created_at.desc()) # Show recently active rooms first
            .offset(skip)
            .limit(limit)
            .all()
        )

        # Get the list of users blocked by the current user
        blocked_target_ids = user_relationship.get_target_ids_by_actor_and_type(
            db,
            actor_anonymous_id=user_anonymous_id,
            relationship_types=[RelationshipTypeEnum.BLOCK]
        )

        filtered_chat_rooms: List[models.ChatRoom] = []
        for room in all_user_chat_rooms_query:
            if not room.is_group:
                # For 1-on-1 chats, find the other participant
                other_participant = None
                if len(room.participants) == 2: # Should always be true for non-group chats
                    for p in room.participants:
                        if p.anonymous_id != user_anonymous_id:
                            other_participant = p
                            break
                if other_participant and other_participant.anonymous_id in blocked_target_ids:
                    continue # Skip this room as the other participant is blocked
            filtered_chat_rooms.append(room)
        return filtered_chat_rooms



    def update_room_updated_at(self, db: Session, *, room_anonymous_id: uuid.UUID) -> Optional[models.ChatRoom]:
        room = self.get_by_anonymous_id(db, anonymous_room_id=room_anonymous_id)
        if room:
            room.updated_at = func.now()
            db.add(room)
            db.commit()
            db.refresh(room)
        return room


class CRUDChatMessage(CRUDBase[models.ChatMessage, schemas.ChatMessageCreate, schemas.ChatMessageBase]): # Update schema might not be needed
    def create_message(
        self,
        db: Session,
        *,
        message_in: schemas.ChatMessageCreate,
        chatroom_anonymous_id: uuid.UUID,
        sender_anonymous_id: uuid.UUID,
    ) -> models.ChatMessage:
        db_obj = models.ChatMessage(
            **message_in.model_dump(),
            chatroom_anonymous_id=chatroom_anonymous_id,
            sender_anonymous_id=sender_anonymous_id
            # anonymous_message_id and timestamp are generated by default
        )
        db.add(db_obj)
        
        # Update the chat room's updated_at timestamp
        chat_room = db.query(models.ChatRoom).filter(models.ChatRoom.anonymous_room_id == chatroom_anonymous_id).first()
        if chat_room:
            chat_room.updated_at = func.now()
            db.add(chat_room)
            
        db.commit()
        db.refresh(db_obj)
        # Eager load sender for immediate use
        db.refresh(db_obj, attribute_names=['sender'])
        return db_obj

    def get_multi_for_room(
        self, db: Session, *, chatroom_anonymous_id: uuid.UUID, skip: int = 0, limit: int = 50
    ) -> List[models.ChatMessage]:
        return (
            db.query(models.ChatMessage)
            .filter(models.ChatMessage.chatroom_anonymous_id == chatroom_anonymous_id)
            .options(joinedload(models.ChatMessage.sender)) # Eager load sender details
            .order_by(models.ChatMessage.timestamp.desc()) # Latest messages first for typical display
            .offset(skip)
            .limit(limit)
            .all()
        )

    def delete_all_messages_by_sender(self, db: Session, sender_anonymous_id: uuid.UUID) -> int:
        """Deletes all chat messages sent by a given user and returns the count."""
        messages_to_delete = db.query(models.ChatMessage).filter(
            models.ChatMessage.sender_anonymous_id == sender_anonymous_id
        ).all()
        count = len(messages_to_delete)
        if count > 0:
            for msg in messages_to_delete:
                db.delete(msg)
            db.commit()
        return count

chat_room = CRUDChatRoom(models.ChatRoom)
chat_message = CRUDChatMessage(models.ChatMessage)