from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from app.schemas.token import Token # Import Token schema
from app import schemas
from app import crud
from app.db.session import get_db
from app.db.models.user import User # For type hinting current_user
from app.core.security import create_access_token
from app.api.v1.deps import get_current_active_user # Import the real dependency
from app.core.config import settings
from datetime import timedelta
import uuid

router = APIRouter()

@router.post("/", response_model=Token, status_code=status.HTTP_201_CREATED)
def create_user_anonymous( # Renamed function for clarity, matching previous discussions
    *,
    db: Session = Depends(get_db),
    user_in: schemas.UserCreate
):
    """
    Create new user.
    Backend generates anonymous_id.
    Returns an access token.
    """
    # anonymous_id is now generated by the backend (in crud.create_user),
    # so we don't check for its existence based on client input here.
    # UUIDs are unique by nature.

    if user_in.username:
        existing_username = crud.crud_user.get_user_by_username(db, username=user_in.username)
        if existing_username:
            raise HTTPException(
                status_code=400,
                detail="Username already registered. Please choose a different one."
            )
    
    try:
        user = crud.crud_user.create_user(db=db, user_in=user_in) # Corrected parameter name to user_in
    except ValueError as e: # Catch potential errors from CRUD, e.g., if generated username still conflicts
        # This might be if a provided username still conflicts (unlikely if pre-checked)
        # or if username generation in CRUD fails (very unlikely).
        raise HTTPException(status_code=400, detail=str(e))
    
    if not user: # Should not happen if CRUD is robust
        raise HTTPException(status_code=500, detail="User creation failed unexpectedly.")
    
    # Generate token for the newly created user
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "anonymous_id": str(user.anonymous_id)}, # Keep str() here for JWT payload
        expires_delta=access_token_expires,
    )
    return {"access_token": access_token, "token_type": "bearer", "username": user.username, "anonymous_id": user.anonymous_id}

@router.get("/me", response_model=schemas.UserRead)
def read_user_me(current_user: User = Depends(get_current_active_user)):
    """
    Get current authenticated user's details.
    """
    return current_user

@router.get("/", response_model=List[schemas.UserRead])
def read_users_endpoint(
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user) # Protect this endpoint
):
    """
    Retrieve users.
    Note: In a production app, this might be restricted to admin users.
    """
    users = crud.crud_user.get_users(db, skip=skip, limit=limit)
    return users

@router.get("/{user_id}", response_model=schemas.UserRead)
def read_user_by_id_endpoint( # Renamed for clarity
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user) # Protect this endpoint
):
    """
    Get a specific user by their internal ID.
    Note: In a production app, access control might be more granular.
    """
    db_user = crud.crud_user.get_user(db, user_id=user_id)
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user

@router.put("/me", response_model=schemas.UserRead) # Changed path to /me for updating self
def update_user_me( # Renamed function for clarity
    *,
    db: Session = Depends(get_db),
    user_in: schemas.UserUpdate,
    current_user: User = Depends(get_current_active_user)
):
    """
    Update current authenticated user's profile.
    """
    # Check if the new username (if provided) is already taken by someone else
    if user_in.username and user_in.username != current_user.username:
        existing_username = crud.crud_user.get_user_by_username(db, username=user_in.username)
        if existing_username:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already registered. Please choose a different one."
            )

    updated_user = crud.crud_user.update_user(db=db, db_user=current_user, user_in=user_in)
    return updated_user

@router.delete("/me", status_code=status.HTTP_204_NO_CONTENT)
def delete_user_me(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user)
):
    """
    Delete the current authenticated user's profile.
    This action is irreversible.
    """
    # The get_current_active_user dependency ensures the user is authenticated and active.
    # We use the anonymous_id from the authenticated user object to perform the deletion.
    deleted_user = crud.crud_user.delete_user_by_anonymous_id(db=db, anonymous_id=current_user.anonymous_id)

    if not deleted_user:
        # This case should theoretically not happen if current_user is valid,
        # but it's a safeguard.
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found (unexpected)")

    return # FastAPI returns 204 No Content for functions that return None or nothing

# Note: A general PUT /users/{user_id} endpoint for admins to update any user
# would require additional admin role checks and is omitted here for simplicity.

@router.get("/anonymous/{user_anonymous_id}", response_model=schemas.UserRead)
def read_user_by_anonymous_id_endpoint(
    user_anonymous_id: uuid.UUID, # Path parameter is a UUID
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_active_user) # Protect this endpoint
):
    """
    Get a specific user by their public anonymous ID.
    Requires authentication to use this endpoint.
    """
    # The current_user dependency already ensures the requester is authenticated.
    # No need to check current_user again here unless for specific authorization logic.

    db_user = crud.crud_user.get_user_by_anonymous_id(db, anonymous_id=user_anonymous_id)
    if db_user is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User with specified anonymous ID not found")
    return db_user

@router.get("/{author_anonymous_id}/posts", response_model=List[schemas.PostRead])
def read_posts_by_author(
    author_anonymous_id: uuid.UUID,
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user) # Protect endpoint
):
    """
    Retrieve posts created by a specific author, identified by their anonymous ID.
    Requires authentication to use this endpoint.
    """
    # First, check if the author exists
    author = crud.crud_user.get_user_by_anonymous_id(db, anonymous_id=author_anonymous_id)
    if not author:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Author not found")

    posts = crud.crud_post.get_multi_posts_by_author_anonymous_id(
        db, author_anonymous_id=author_anonymous_id, skip=skip, limit=limit
    )
    # The posts list will be automatically converted to List[schemas.PostRead]
    # by FastAPI, assuming the Post ORM objects are compatible and PostRead
    # has from_attributes=True (which it does).
    return posts

@router.get("/{author_anonymous_id}/comments", response_model=List[schemas.CommentRead])
def read_comments_by_author(
    author_anonymous_id: uuid.UUID,
    db: Session = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user) # Protect endpoint
):
    """
    Retrieve comments created by a specific author, identified by their anonymous ID.
    Requires authentication to use this endpoint.
    """
    # First, check if the author exists
    author = crud.crud_user.get_user_by_anonymous_id(db, anonymous_id=author_anonymous_id)
    if not author:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Author not found")

    comments = crud.comment.get_multi_by_author_anonymous_id(
        db, author_anonymous_id=author_anonymous_id, skip=skip, limit=limit
    )
    # The comments list will be automatically converted to List[schemas.CommentRead]
    # by FastAPI.
    return comments
    return posts